{"remainingRequest":"/Users/yschoi/Desktop/workspace/yschoi/frontend/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/yschoi/Desktop/workspace/yschoi/frontend/src/views/dashboard/component/DoughnutChart.vue?vue&type=style&index=0&id=0e6c9ab6&lang=scss&scoped=true&","dependencies":[{"path":"/Users/yschoi/Desktop/workspace/yschoi/frontend/src/views/dashboard/component/DoughnutChart.vue","mtime":1609822487987},{"path":"/Users/yschoi/Desktop/workspace/yschoi/frontend/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yschoi/Desktop/workspace/yschoi/frontend/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/yschoi/Desktop/workspace/yschoi/frontend/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/yschoi/Desktop/workspace/yschoi/frontend/node_modules/sass-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yschoi/Desktop/workspace/yschoi/frontend/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yschoi/Desktop/workspace/yschoi/frontend/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCmgxIHsKICBtYXJnaW46IDA7CiAgcGFkZGluZzogMDsKfQoKLnZhbHVlLWNvbnRhaW5lciB7CiAgZGlzcGxheTogZmxleDsKICBmbGV4LWZsb3c6IGNvbHVtbiBub3dyYXA7CiAgYWxpZ24taXRlbXM6IGNlbnRlcjsKICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsKICB3aWR0aDogMTAwJTsKICBoZWlnaHQ6IDEwMCU7CiAgcG9zaXRpb246IGFic29sdXRlOwogIHRvcDogMDsKICBsZWZ0OiAwOwp9Cg=="},{"version":3,"sources":["DoughnutChart.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgQA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"DoughnutChart.vue","sourceRoot":"src/views/dashboard/component","sourcesContent":["<template>\n  <div class='doughnut_chart' style='position:relative;'>\n    <svg :width='width' :height='height' viewBox='0 0 200 200' style='stroke-linecap:round;'>\n      <!-- Background circle -->\n      <path :d='dBg' fill='transparent'\n            :stroke=\"(backgroundColor && validateColor(backgroundColor)) ? backgroundColor : '#ecf6ff'\"\n            :stroke-width='strokeWidth' />\n      <!-- Move to start position, start drawing arc -->\n      <path :d='d' fill='transparent'\n            :stroke=\"(foregroundColor && validateColor(foregroundColor)) ? foregroundColor : '#1993ff'\"\n            :stroke-width='strokeWidth' />\n    </svg>\n    <div\n        v-if='visibleValue'\n        class='value-container'\n    >\n      <template v-if='passTextAsHtml'>\n        <div\n            v-if='customText.length'\n            :style='customTextStyle'\n            v-html='customText'\n        />\n      </template>\n      <template v-else>\n        <h1\n            v-if='percent'\n            :class='classValue'\n            :style='valueStyle'\n        >\n          {{ valueCountUp ? countingUpValue + '%' : percent + '%' }}\n        </h1>\n        <div\n            v-if='customText.length'\n            v-html='customText'\n            :class='classValue'\n            :style='customTextStyle'\n        />\n      </template>\n    </div>\n    <div\n        v-else-if='customText.length'\n        class='value-container'\n    >\n      <div\n          v-if='customText.length'\n          v-html='customText'\n          :class='classValue'\n          :style='customTextStyle'\n      />\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \"DoughnutChart\",\n  props: {\n    percent: {\n      default: 0\n    },\n    foregroundColor: {\n      type: String,\n      default: \"#1993ff\"\n    },\n    backgroundColor: {\n      type: String,\n      default: \"#ecf6ff\"\n    },\n    strokeWidth: {\n      type: Number,\n      default: 10\n    },\n    radius: {\n      type: Number,\n      default: 85\n    },\n    width: {\n      type: Number,\n      default: 200\n    },\n    height: {\n      type: Number,\n      default: 200\n    },\n    classValue: {\n      type: String,\n      default: \"\"\n    },\n    visibleValue: {\n      type: Boolean,\n      default: false\n    },\n    valueCountUp: {\n      type: Boolean,\n      default: false,\n      required: false\n    },\n    valueCountUpDuration: {\n      type: Number,\n      default: 2000,\n      required: false\n    },\n    valueCountUpDelay: {\n      type: Number,\n      default: 500,\n      required: false\n    },\n    customPercentSize: {\n      type: Number,\n      default: 40,\n      required: false\n    },\n    passTextAsHtml: {\n      type: Boolean,\n      default: false\n    },\n    customText: {\n      type: String,\n      default: \"\"\n    },\n    customTextColor: {\n      type: String,\n      default: '',\n      required: false\n    },\n    customTextSize: {\n      type: Number,\n      default: 15,\n      required: false\n    }\n  },\n  data() {\n    return {\n      countingUpValue: 0,\n      delayTimer: null\n    };\n  },\n  computed: {\n    // If more than 50% filled we need to switch arc drawing mode from less than 180 deg to more than 180 deg\n    largeArc() {\n      const number = this.valueCountUp ? this.countingUpValue : this.percent\n      return parseInt(number) < 50 ? 0 : 1;\n    },\n    // Where to put x coordinate of center of circle\n    x() {\n      return 100;\n    },\n    // Where to put y coordinate of center of circle\n    y() {\n      return 100 - this.radius;\n    },\n    // Calculate X coordinate of end of arc (+ 100 to move it to middle of image)\n    // add some rounding error to make arc not disappear at 100%\n    endX() {\n      return -Math.sin(this.radians) * this.radius + 100 - 0.0001; // eslint-disable-line no-mixed-operators\n    },\n    // Calculate Y coordinate of end of arc (+ 100 to move it to middle of image)\n    endY() {\n      return Math.cos(this.radians) * this.radius + 100; // eslint-disable-line no-mixed-operators\n    },\n    // Calculate length of arc in radians\n    radians() {\n      const number = this.valueCountUp ? this.countingUpValue : this.percent\n      const degrees = ( number / 100 ) * 360;\n      const value = degrees - 180; // Turn the circle 180 degrees counter clockwise\n\n      return ( value * Math.PI ) / 180;\n    },\n    // If we reach full circle we need to complete the circle, this ties into the rounding error in X coordinate above\n    z() {\n      const number = this.valueCountUp ? this.countingUpValue : this.percent\n      return parseInt(number) === 100 ? \"z\" : \"\";\n    },\n    dBg() {\n      return `M ${ this.x } ${ this.y } A ${ this.radius } ${ this.radius } 0 1 1 ${ this\n          .x - 0.0001 } ${ this.y } z`;\n    },\n    d() {\n      return `M ${ this.x } ${ this.y } A ${ this.radius } ${ this.radius } 0 ${ this.largeArc } 1 ${ this.endX } ${ this.endY } ${ this.z }`;\n    },\n    valueStyle() {\n      let percentColor = ( this.foregroundColor && this.validateColor(this.foregroundColor) ) ? this.foregroundColor : '#1993ff'\n      let percentSize = ( this.customPercentSize && this.customPercentSize < 60 ) ? `${ this.customPercentSize }px` : false\n      return {\n        color: percentColor,\n        fontSize: percentSize,\n        margin: '0 auto'\n      };\n    },\n    customTextStyle() {\n      let textColor = ( this.customTextColor && this.validateColor(this.customTextColor) ) ? this.customTextColor : this.foregroundColor\n      let textWidth = this.strokeWidth ? `calc(100% - ${ this.strokeWidth * 2 }px)` : 'calc(100% - 20px)'\n      let textPadding = ( this.strokeWidth && this.strokeWidth > 7 && this.strokeWidth <= 18 ) ? `0 ${ this.strokeWidth }px` : '0 10px'\n      let textSize = ( this.customTextSize && this.customTextSize <= 22 ) ? `${ this.customTextSize }px` : false\n      let customTopMargin = ( this.strokeWidth && this.strokeWidth > 7 && this.strokeWidth <= 18 ) ? this.strokeWidth : 5\n      return {\n        color: textColor,\n        width: textWidth,\n        padding: textPadding,\n        margin: `-${ customTopMargin }px auto 0`,\n        textAlign: 'center',\n        fontSize: textSize,\n        wordBreak: \"break-all\",\n        wordWrap: \"break-word\"\n      };\n    }\n  },\n  mounted() {\n    if (this.valueCountUp && this.percent) {\n      this.countUpPercent()\n    }\n  },\n  watch: {\n    percent() {\n      const delay = this.valueCountUpDelay ? this.valueCountUpDelay : 500\n      if (this.delayTimer) {\n        clearTimeout(this.delayTimer)\n        this.delayTimer = null\n      }\n      this.delayTimer = setTimeout(() => {\n        this.countUpPercent()\n      }, delay)\n    }\n  },\n  methods: {\n    validateColor(string) {\n      let s = new Option().style\n      s.color = string\n      // must match a valid css color or hex value\n      return s.color !== '' || /^#([0-9A-F]{3}){1,2}$/i.test(s.color);\n    },\n    countUpPercent() {\n      if (this.percent === this.countingUpValue) {\n        return;\n      }\n      const animationDuration = this.valueCountUpDuration;\n      const frameDuration = 1000 / 60; // Calculate how long each 'frame' should last if we want to update the animation 60 times per second\n      const totalFrames = Math.round(animationDuration / frameDuration); // Use that to calculate how many frames we need to complete the animation\n      const easeOutQuad = t => t * ( 2 - t ); // An ease-out function that slows the count as it progresses\n      let frame = 0; // The animation function, which takes an Element\n      const counter = setInterval(() => {\n        frame++\n        const progress = easeOutQuad(frame / totalFrames) // Calculate our progress as a value between 0 and 1\n        if (this.countingUpValue !== this.percent) {\n          this.countingUpValue = Math.round(this.percent * progress) // Use the progress value to calculate the current count\n        }\n        if (frame === totalFrames) {\n          clearInterval(counter)\n        }\n      }, frameDuration);\n\n    }\n  }\n};\n</script>\n<style lang='scss' scoped>\nh1 {\n  margin: 0;\n  padding: 0;\n}\n\n.value-container {\n  display: flex;\n  flex-flow: column nowrap;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n</style>"]}]}